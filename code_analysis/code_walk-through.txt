	Once Pyethapp is installed and running correctly with a complete copy of the blockchain as outlined in the previous section, we are ready to proceed with the code walk-through as provided through the wiki. At this point, Pyethapp goes through its functional processes: receiving and decoding network data; message handling; and processing blocks within the blockchain ecosystem. The wiki has been left open for additional explanation as to the extended functionality of the Pyethapp client, but this wiki currently covers only the process of a block from the network socket (a point in a computer system for sending and receiving data in a network) to one’s hard drive. In the process of receiving and decoding network data, Pyethapp looks to peer.py in the pydevp2p library to wait for incoming data and if it sees a message, it is added to the session for that node. The Pyethapp node (the computer system that is running the Pyethapp) then looks to muxsession.py to attempt decoding of packets following the nodes handshaking (communication between nodes) on the blockchain network. Multiplexer.py then decodes the message if enough packets were collected from previous steps using a cipher within the RLPx (cryptographic peer-to-peer network and protocol suite used by Ethereum) session via rlpxcipher.py. Decoded packets are then put into a queue and are processed through peer.py via a number of greenlets (small sequences of program instructions that are managed within the processes as defined in peer.py). The packet is then handled by peer.py by passing it to a handling protocol which determines if the packet can be passed along to the ‘eth’ protocol via eth_protocol.py.
	The eth protocol is linked to a chain service via eth_service.py which registers callbacks (code that is passed to other code to be used at an assigned time) within the first stage of message handling. The callbacks are called through protocol.py after the packet id is resolved to a handling operation.  Since we are using the eth protocol, the new block we are creating will be passed the packets which will be decoded through eth_protocol.py and callbacks will be handled following identification of the packets through eth_service.py. New blocks are then handled and synchronized via synchronizer.py. The synchronizer checks: if the block is unknown; if the proof-of-work is valid; if the chain difficulty is sufficient; and if the parent exists for the new block. If all of these meet the thresholds of the synchronizer, the new block is added to the queue by eth_service.py. This is once again handled via a greenlet which attempts to push the new block onto the blockchain.
	Before the new block can be added to the blockchain (so that it can access its ancestors on the legitimate blockchain and to prove its state-of-value), it must first be stripped of its initial serialization (acquired for the purpose of processing the packets into a block through the initial processes) through eth_service.py and is passed along to become a legitimate block by eth_protocol.py. Pyethereum and Pyrlp are then used to structure and validate the block to prevent errors (blocks.py) before it is passed along for serialization in accordance with the RLP standard established for the Ethereum blockchain (sedes/lists.py) and the larger Ethereum protocol.
	Once the block has been checked, the Pyethereum library is used to update the state of the block through executed transaction (blocks.py; processblock.py). These transactions that are to become a part of the block are validated through processblock.py which then updates the sender’s nonce (a meaningless value in a block which can be adjusted in order to satisfy the proof-of-work condition), gas (a measurement roughly equivalent to computational steps which every transaction is required to include a limit of and a fee that it is willing to pay per gas) is processed, and an account message and call data are prepared. Processblock.py then applies the message to the system and the value within the transaction is transferred. The Ethereum virtual machine is then used via vm.py to establish reading and writing of transactions to the Ethereum state and to limit access. Transactions being written to update the block state are cached and recorded as to revert them if they are illegitimate. If a message processed through processblock.py is successfully applied to a state update, it is identified as valid and is committed to the new block via blocks.py. Transactions continue to be applied and validated until the new block is finalized at which point Pyethapp’s eth_service.py verifies the new block.
	If the new block passes the check via Pyethapp’s eth_service.py, we are now ready to add the block to the blockchain. The Pyethereum library’s chain.py prepares to add the block by first checking the block’s uncles (or ommer: a child of an ancestor that is not an ancestor) and verifying the block’s validity once again through checking it’s parent blocks. Chain.py then updates the index after checking the blockchain length and work quantity so that the child (our new block) can be loaded with the transaction that occurred during the time the block was being generated. The block is then stored in preparation to be encoded and loaded to the blockchain where it is issued a temporary key for holding its place (refcount_db.py) and shifted into a proper position for pre-entry into the blockchain (leveldb_service.py). The blockchain head (newest blocks indexed on the legitimate blockchain) is then updated via chain.py which then updates the new block for addition in sync with the head. Finally, chain.py passes this information to refcount_db.py where the blockchain journal and death row are updated for the commit (publication) of the new block.
